name: Finalize Changelog for Release

on:
  push:
    tags:
      - "v*"
      - "!v*-rc*" # Exclude pre-release tags

permissions:
  contents: write

jobs:
  finalize:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_CHANGELOG }}
          fetch-depth: 0
          ref: main

      - name: Ensure tag is on preprod
        run: |
          git fetch origin preprod
          if ! git merge-base --is-ancestor "$GITHUB_SHA" origin/preprod; then
            echo "âŒ Tag ${{ github.ref_name }} must be on preprod branch"
            exit 1
          fi
          echo "âœ… Tag is on preprod branch"

      - name: Extract version from tag
        id: version
        run: |
          TAG="${GITHUB_REF_NAME}"
          # Remove 'v' prefix for folder name (v1.1.0 -> 1.1.0)
          VERSION_NUMBER="${TAG#v}"

          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "version_number=${VERSION_NUMBER}" >> $GITHUB_OUTPUT
          echo "Release version: ${TAG}"
          echo "Archive folder: ${VERSION_NUMBER}"

      - name: Check for RC version in CHANGELOG.md
        id: check_rc
        run: |
          VERSION="${{ steps.version.outputs.tag }}"
          RC_VERSION="${VERSION}-rc"

          if [ -f CHANGELOG.md ] && grep -q "^## ${RC_VERSION}" CHANGELOG.md; then
            echo "has_rc=true" >> $GITHUB_OUTPUT
            echo "rc_version=${RC_VERSION}" >> $GITHUB_OUTPUT
            echo "Found RC version in CHANGELOG.md: ${RC_VERSION}"
          else
            echo "has_rc=false" >> $GITHUB_OUTPUT
            echo "No RC version found, will aggregate fresh"
          fi

      - name: Update CHANGELOG.md (remove -rc suffix)
        if: steps.check_rc.outputs.has_rc == 'true'
        run: |
          VERSION="${{ steps.version.outputs.tag }}"
          RC_VERSION="${{ steps.check_rc.outputs.rc_version }}"

          echo "Updating ${RC_VERSION} -> ${VERSION} in CHANGELOG.md"

          sed -i "s/^## ${RC_VERSION}/## ${VERSION}/" CHANGELOG.md

          echo "âœ… CHANGELOG.md updated"
          echo ""
          echo "Preview:"
          head -n 30 CHANGELOG.md

      - name: Aggregate changelogs (if no RC existed)
        if: steps.check_rc.outputs.has_rc == 'false'
        run: |
          VERSION="${{ steps.version.outputs.tag }}"

          echo "No pre-release found, aggregating changelogs for final release..."

          # Create temporary files for each section
          TEMP_DIR=$(mktemp -d)
          ADDED="${TEMP_DIR}/added.txt"
          CHANGED="${TEMP_DIR}/changed.txt"
          FIXED="${TEMP_DIR}/fixed.txt"
          REMOVED="${TEMP_DIR}/removed.txt"
          DEPRECATED="${TEMP_DIR}/deprecated.txt"
          SECURITY="${TEMP_DIR}/security.txt"
          TECHNICAL="${TEMP_DIR}/technical.txt"

          touch "$ADDED" "$CHANGED" "$FIXED" "$REMOVED" "$DEPRECATED" "$SECURITY" "$TECHNICAL"

          # Process each feature changelog
          FEATURE_COUNT=0
          for file in changelogs/feat-*.md; do
            if [ -f "$file" ]; then
              FEATURE_COUNT=$((FEATURE_COUNT + 1))
              FEATURE_NAME=$(basename "$file" .md)
              echo "Processing: ${file}"
              
              CURRENT_SECTION=""
              
              while IFS= read -r line; do
                # Skip comments and empty lines
                if [[ "$line" =~ ^[[:space:]]*$ ]] || [[ "$line" =~ ^\<\!-- ]]; then
                  # If we hit the guidelines comment, stop processing this file
                  if [[ "$line" =~ ^\<\!--[[:space:]]*Guidelines ]]; then
                    break
                  fi
                  continue
                fi
                
                if [[ "$line" =~ ^###[[:space:]]*(Added|Changed|Fixed|Removed|Deprecated|Security) ]]; then
                  CURRENT_SECTION="${BASH_REMATCH[1]}"
                  continue
                fi
                
                if [[ "$line" =~ ^###[[:space:]]*Technical[[:space:]]*Notes ]]; then
                  CURRENT_SECTION="Technical"
                  continue
                fi
                
                if [[ "$line" =~ ^-[[:space:]]+ ]] && [[ -n "$CURRENT_SECTION" ]]; then
                  # Skip bullet points that are empty or just whitespace after the dash
                  CONTENT=$(echo "$line" | sed 's/^-[[:space:]]*//')
                  if [[ -z "$CONTENT" ]]; then
                    continue  # Skip empty bullet point
                  fi
                  
                  ATTRIBUTED_LINE="${line} *(${FEATURE_NAME})*"
                  
                  case "$CURRENT_SECTION" in
                    "Added") echo "$ATTRIBUTED_LINE" >> "$ADDED" ;;
                    "Changed") echo "$ATTRIBUTED_LINE" >> "$CHANGED" ;;
                    "Fixed") echo "$ATTRIBUTED_LINE" >> "$FIXED" ;;
                    "Removed") echo "$ATTRIBUTED_LINE" >> "$REMOVED" ;;
                    "Deprecated") echo "$ATTRIBUTED_LINE" >> "$DEPRECATED" ;;
                    "Security") echo "$ATTRIBUTED_LINE" >> "$SECURITY" ;;
                    "Technical") echo "$ATTRIBUTED_LINE" >> "$TECHNICAL" ;;
                  esac
                fi
              done < "$file"
            fi
          done

          echo "Processed ${FEATURE_COUNT} feature changelog(s)"

          # Build the aggregated changelog
          AGGREGATED="${TEMP_DIR}/aggregated.txt"
          echo "## ${VERSION}" > "$AGGREGATED"
          echo "" >> "$AGGREGATED"

          [ -s "$ADDED" ] && { echo "### Added" >> "$AGGREGATED"; cat "$ADDED" >> "$AGGREGATED"; echo "" >> "$AGGREGATED"; }
          [ -s "$CHANGED" ] && { echo "### Changed" >> "$AGGREGATED"; cat "$CHANGED" >> "$AGGREGATED"; echo "" >> "$AGGREGATED"; }
          [ -s "$FIXED" ] && { echo "### Fixed" >> "$AGGREGATED"; cat "$FIXED" >> "$AGGREGATED"; echo "" >> "$AGGREGATED"; }
          [ -s "$REMOVED" ] && { echo "### Removed" >> "$AGGREGATED"; cat "$REMOVED" >> "$AGGREGATED"; echo "" >> "$AGGREGATED"; }
          [ -s "$DEPRECATED" ] && { echo "### Deprecated" >> "$AGGREGATED"; cat "$DEPRECATED" >> "$AGGREGATED"; echo "" >> "$AGGREGATED"; }
          [ -s "$SECURITY" ] && { echo "### Security" >> "$AGGREGATED"; cat "$SECURITY" >> "$AGGREGATED"; echo "" >> "$AGGREGATED"; }
          [ -s "$TECHNICAL" ] && { echo "### Technical Notes" >> "$AGGREGATED"; cat "$TECHNICAL" >> "$AGGREGATED"; echo "" >> "$AGGREGATED"; }

          # Update CHANGELOG.md
          if [ -f CHANGELOG.md ]; then
            TEMP_CHANGELOG="${TEMP_DIR}/new_changelog.md"
            head -n 2 CHANGELOG.md > "$TEMP_CHANGELOG"
            cat "$AGGREGATED" >> "$TEMP_CHANGELOG"
            echo "" >> "$TEMP_CHANGELOG"
            tail -n +3 CHANGELOG.md >> "$TEMP_CHANGELOG"
            mv "$TEMP_CHANGELOG" CHANGELOG.md
          else
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            cat "$AGGREGATED" >> CHANGELOG.md
          fi

          rm -rf "$TEMP_DIR"
          echo "âœ… Changelog aggregated"

      - name: Archive feature changelogs
        id: archive
        run: |
          VERSION_NUMBER="${{ steps.version.outputs.version_number }}"
          ARCHIVE_DIR="changelogs/${VERSION_NUMBER}"

          # Create archive directory
          mkdir -p "$ARCHIVE_DIR"

          # Move all feature changelogs to archive
          ARCHIVED_COUNT=0
          for file in changelogs/feat-*.md; do
            if [ -f "$file" ]; then
              mv "$file" "$ARCHIVE_DIR/"
              ARCHIVED_COUNT=$((ARCHIVED_COUNT + 1))
              echo "Archived: $(basename "$file")"
            fi
          done

          if [ $ARCHIVED_COUNT -eq 0 ]; then
            echo "âš ï¸  No feature changelogs to archive"
            rmdir "$ARCHIVE_DIR"
            echo "archived=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Archived ${ARCHIVED_COUNT} changelog(s) to ${ARCHIVE_DIR}"
            echo "archived=true" >> $GITHUB_OUTPUT
            echo "archive_dir=${ARCHIVE_DIR}" >> $GITHUB_OUTPUT
            echo "count=${ARCHIVED_COUNT}" >> $GITHUB_OUTPUT
          fi

      - name: Commit changelog finalization
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add CHANGELOG.md

          if [ "${{ steps.archive.outputs.archived }}" = "true" ]; then
            git add changelogs/
            git commit -m "chore: finalize changelog and archive features for ${{ steps.version.outputs.tag }}"
          else
            git commit -m "chore: finalize changelog for ${{ steps.version.outputs.tag }}"
          fi

          git push origin main

          echo "âœ… Changes committed and pushed to main"

      - name: Extract changelog for release body
        id: extract
        run: |
          VERSION="${{ steps.version.outputs.tag }}"

          # Extract just this version's section
          TEMP_FILE=$(mktemp)

          awk "/^## ${VERSION}/,/^## / {
            if (/^## / && !/^## ${VERSION}/) exit;
            if (!/^## ${VERSION}/) print;
          }" CHANGELOG.md > "$TEMP_FILE"

          echo "Release body preview:"
          cat "$TEMP_FILE"

          echo "body_file=${TEMP_FILE}" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: "Release ${{ steps.version.outputs.tag }}"
          body_path: ${{ steps.extract.outputs.body_file }}
          generate_release_notes: true
          append_body: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Add release summary
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ steps.version.outputs.tag }}';
            const archived = '${{ steps.archive.outputs.archived }}';
            const count = '${{ steps.archive.outputs.count }}';
            const archiveDir = '${{ steps.archive.outputs.archive_dir }}';

            let summary = `# ðŸš€ Release ${version} Published\n\n`;
            summary += `âœ… CHANGELOG.md updated\n`;

            if (archived === 'true') {
              summary += `âœ… ${count} feature changelog(s) archived to \`${archiveDir}\`\n`;
            }

            summary += `âœ… GitHub release created with combined changelog\n`;

            core.summary.addRaw(summary).write();
